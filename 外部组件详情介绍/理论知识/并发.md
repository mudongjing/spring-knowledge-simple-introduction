# 线程

实现线程执行单元可以是继承Thread，或实现Runnable接口，二者的区别在于，Runnable可以作为实例被其它的Thread共享。

线程在创建时，都是有一个父线程负责创建，而这个符线程一般就是执行的main函数线程。

守护线程具备自己自动结束声明周期的特点。

> 普通的线程，如果我们不去手动结束它的话，它一般不会自己结束，而jvm在发现还有这样的线程存在时，也不敢自己结束，只能保持存活，相反的，如果只剩下守护线程，则表示没有额外用户操作，可以退出，而这个退出过程，则可以由守护线程做一些操作，比如，可以强制某些线程停止。

线程之间的休眠是互不影响的，即使是主线程和子线程之间。

> 休眠，sleep可以用TimeUnit负责，因为可以明确地使用小时、分钟等，
>
> ```java
> Thread.sleep(12257088L);
> TimeUnit.HOURS.sleep(3);
> TimeUnit.MINUTES.sleep(24);
> TimeUnit.SECONDS.sleep(17);
> TimeUnit.MILLISECONDS.sleep(88) ;
> ```

yield 方法属于一种启 发式的方法，其会提醒调度器我愿意放弃当前的 CPU 资源，如果CPU 的资源不紧张，则会忽略这种提醒 。

中断当前的线程，可以调用`interrupt`方法，用以打破阻塞，不是等价于结束线程

> 应用的场景组要是对于线程在休眠或等待时，导致这段时间无法工作，实际内部是为线程添加了一个标志` interrupt flag`，如果其它线程调用了该线程的interrupt方法，则线程会被抹除这个标志，从而继续下面的工作。
>
> 如果我们提前执行了中断，那么之后调用可终端方法时，会立即执行中断。

join方法会让当前的线程会等待指定线程执行结束，或只是等待到达一定时间，

> 比如我们执行某一功能时，必须等待其它几个线程把数据提取好，才能统一进行分析在返回给用户，则需要让我们的分析线程等待其它几个数据线程完成工作才可以，否则，得到的结果必然时存在问题的。

在线程关闭自己时，不要用`stop`，

> 可以在run方法中编写执行逻辑时，强调需要在无中断信号时执行工作，当接收到中断信号后，自然会停止一切工作，完成关闭。但因为中断信号的可能太多，既有可能发生误判。
>
> 此外可以利用类似锁机制的方式，在线程内部准备一个变量，必须是`volatile`类型，如同前面的中断方式一样，如果这个变量不变化就继续工作，通过额外的一个方法改变这个变量，就可以处理工作停止的结果。



# 安全

当多个线程同时运行，且分享一些共有变量时，如果没有完善的浴缸手段，那么在对变量的操作中，可能一方正在对变量操作，cpu的执行权就移交给另一个线程，而那个线程也在执行一个变量操作，结果就是这个线程修改后，返还给最初的线程，又把自己当初的工作完成一遍，导致变量不停变脸，分不清到底是什么样。

synchronized

> 内部包含两个关键字，JVM命令`monitor enter` 和`monitor exit`，
>
> > 它能够保证在任何时候任何线程执行到 monitor enter 成功之前都必须从主内存中获取数据， 而
> > 不是从缓存中，在 monitor exit 运行成功之后，共享变量被更新后的值必须刷入主内存
>
> 我们可以同步修饰一个方法，也可以使用某一个类对象来同步修饰一段代码块。
>
> > 同一个类中的方法最好只能有一个方法被同步修饰，如果是多个，会互相争夺锁，而锁就是类本身对应的。
>
> > 通过对象，来使用同步的机制，一般是把对象作为锁来说明，实际我们是获取对象背后的monitor锁。
> >
> > > 获取到monitor锁后，才能执行`monitor enter` 和`monitor exit`，从而保证同步一致性。
> > >
> > > monitor有一个计数器，线程使用它就加1，同一个线程可以多次使用，即重入锁。monitor enter就是负责加1的那部分。
>
> 使用`jstack -l pid名`可以查看线程锁的问题。

volatile修饰的变量之所以是对全局可见的，在于

> 正常而言，线程修改变量时，需要把变量放在自己的工作内存中，然后再交由CPU执行操作，当完成操作后，再返还到对应的主内存中。
>
> 因此，如果多线程公用一个变量时，由于多个线程会将变量生成一个副本放在自己的工作内存中，加之CPU与内存工作速度的巨大差距，多个线程的操作，可能在很短的时刻内，多个线程都将自己的结果放到主内存中，或者自己作为结果输出。
>
> 这里的解决方案，就是在CPU处理了这样一个共享变量后，里面通知其它该变量的副本无效，如果线程要使用，必须到主内存中获取。
>
> 当然了，前面也说了CPU和内存速度的差距，实际的线程的副本变量可能就是放在CPU的缓存中。

同时volatile也实现了语句命令的有序性。

> 比如我们使用volatile修饰了一个变量后，那么，该语句前面的操作必然是在该语句之前完成，不会放在该语句之后的命令之后执行，后面的语句也类似。
>
> 底层实际是添加了内存屏障，拦截了两边的指令，不使得前后两条命令越过屏障。



# 通信

通过 `wait`或`notify`可以通知对应的线程是等待还是现在执行工作

> wait方法是对象类共有的，且使用的话必须在同步方法中，与同步方法使用统一的锁。

当涉及多线程的时候，则使用notifyall。

> 当线程被wait之后，会放在一个wait set结构中。

如果仅使用synchronized作为锁的话，我们无法自由地关闭某个线程，导致可能存在某一线程执行过久，导致后面的线程需要的条件均失效，由此，我们需要一种锁，能够使用中断等方式解除锁机制，

> 可行的方案，就是实现一个接口，允许加锁，和解锁。



