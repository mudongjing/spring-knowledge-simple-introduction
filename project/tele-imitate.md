```merm
flowchart TD
  u(URI);r(REDIS);s(SQL);n(NEO4J);c[磁盘文件]
  q((请求));g(GROUP);xx(MESSAGE)
  us(USER);f(FRIENDS);m(Members)
style q fill:#d0021b
style us fill:#4a90e2
style s fill:#8fec28
style r fill:#8fec28
style g fill:#4a90e2
style m fill:#f5a623
style xx fill:#f5a623
style c fill:#bd10e0
  q---->|查询信息,包含各种数据获取|u
  u-->|先查询缓存|r
  r---->|缓存未击中|s;
  
  g---->|输出和接收消息|xx
  xx---->|自动创建对应该群组的消息数据表|s

  g---->|用户列表|m-->|保存为集合类型,存储为txt文件|c;
  g-..->|添加和删除成员|m
  g---->|自动创建一个自己的数据表|s
  g-->自我销毁
  s-->|通过路径读取数据文件|c 
  xx-.->|缓存,按时间保存为有序集合|r

  r-->|当消息达到一定数量或期限,返还到磁盘文件中|c
  us-..->|用户创建群组|g 
  us-..->|发送消息|g
  us-..->|加入或退出群组|g
  us---->|用户列表存储|s;
  us---->f-->|内部好友列表存储|n;
  f---->|作为字符串|s
  f-..->|分为两种格式varchar和text|s
  us-.->查询消息-.->q
  us-.->查询自己加入的群组-.->q
```

![](https://mudongjing.github.io/gallery/project/plan/tele-imi.jpg)

# 介绍

我们试图练习一下，实现一个聊天项目，主要的目的是向着telegram的方向一点点实现，初步的内容就是实现群组，频道的规划。

> 底层为mysql持久化，中间利用redis做缓存，最后整合ES实现消息搜索。

# 策划

作为主要的用户，需要详细规划内部的信息组织，

> ```
> - id: 自增长，用于索引
> - 名字： 用户自己的取名，需要保证唯一性
> - 好友列表： 存储的是好友的id
> - 群组/频道列表： 存储这些的对应的id
> ```
>
> > 群组或频道的列表，我们暂不做过高的预期，最多支持到text的类型，估计最多可以加入1000个。
>
> ```
> # 需要实现的功能主要有
> - 创建/删除 群组/频道：
> - 加入/退出 群组/频道：
> - 获取群组/频道消息：
> - 向群组/频道发送消息：
> ```

对应的，需要计划群组和频道的功能，由于频道可以看作是功能阉割版的群组，这里仅介绍群组的主要功能

> ```
> # 组织
> - id：
> - 群族名：
> - 创建者：
> - 用户列表：
> - 群组消息内容：
> ```
>
> > 由于群组或频道容易收到大量的关注，用户极易扩大，因此默认使用MEDIUMTEXT记录用户列表
> >
> > 消息内容，则另外准备一个数据表存储，包括消息的发送者，内容，类型【因为可能是图片或视频】，时间。
>
> ```
> # 功能
> - 输出/接收消息
> - 加入/移除用户：
> - 自我销毁：删除其中的所有内容
> ```

# 底层

## 成员列表

群组/频道的成员列表可能会不断发生变化，尤其是增加用户，如果采用字符串方式，可以简单地增加成员，但是如果是删除某一成员则困难一些。

为此需要使用hashset存储，方便快速查询，在存储存储方式上，保存为txt文件格式，

实际操作中，自然是多放在redis中

> 当访问一次，过期时间就延长一次。
>
> 在redis也同样使用集合形式存储，当过期时，再返回更新本地的文件

## 好友列表

作为用户的好友，增加的机会最多，而删除的时机则很少，因此就保存为字符串即可

## 消息数据表

当创建一个群组或频道时，同时创建一个对应的消息数据表，专门用于存储消息

> 同样的，如果只是使用mysql，大量的消息太过频繁，使用redis做中间缓存，当储备了足够数量的消息，再持久化到mysql中
>
> 同样的，mysql的中的消息，再用户进入群组时，需要获取对应的消息，系统先从redis中获取数据，再从数据库中提取一定量的消息，如果再获取，就再提取更久以前的一部分数据。







